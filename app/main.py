# Admin Username: 
# c1f96b08fa7efdfb3732fca9db56e39a594944b2b14c5a95cce11a2e24de5b2d   
# FTP host server: ftps://waws-prod-dm1-349.ftp.azurewebsites.windows.net/site/wwwroot
# psswrd: owQbAQjcdR5jtiuL2jMvKebmD5lJj3pHiwaRAuXE8wqhRXLyH4vsZ1prFTqm
'''                                                                                                                                                       
#                                      dddddddd                                                                                                                     
#   iiii                               d::::::d                                                                                                                     
#  i::::i                              d::::::d                                                                                                                     
#   iiii                               d::::::d                                                                                                                     
#                                      d:::::d                                                                                                                      
# iiiiiiinnnn  nnnnnnnn        ddddddddd:::::dyyyyyyy           yyyyyyy                                                                                             
# i:::::in:::nn::::::::nn    dd::::::::::::::d y:::::y         y:::::y                                                                                              
#  i::::in::::::::::::::nn  d::::::::::::::::d  y:::::y       y:::::y                                                                                               
#  i::::inn:::::::::::::::nd:::::::ddddd:::::d   y:::::y     y:::::y                                                                                                
#  i::::i  n:::::nnnn:::::nd::::::d    d:::::d    y:::::y   y:::::y                                                                                                 
#  i::::i  n::::n    n::::nd:::::d     d:::::d     y:::::y y:::::y                                                                                                  
#  i::::i  n::::n    n::::nd:::::d     d:::::d      y:::::y:::::y                                                                                                   
#  i::::i  n::::n    n::::nd:::::d     d:::::d       y:::::::::y                                                                                                    
# i::::::i n::::n    n::::nd::::::ddddd::::::dd       y:::::::y                                                                                                     
# i::::::i n::::n    n::::n d:::::::::::::::::d        y:::::y                                                                                                      
# i::::::i n::::n    n::::n  d:::::::::ddd::::d       y:::::y                                                                                                       
# iiiiiiii nnnnnn    nnnnnn   ddddddddd   ddddd      y:::::y                                                                                                        
#                                                   y:::::y                                                                                                         
#                                                  y:::::y                                                                                                          
#                                                 y:::::y                                                                                                           
#                                                y:::::y                                                                                                            
#                                               yyyyyyy                                                                                                             
#                                                                                                                           iiii                                    
#                                                                                                                          i::::i                                   
#                                                                                                                           iiii                                    
                                                                                                                                                                  
#   aaaaaaaaaaaaa      ssssssssss       ssssssssss     aaaaaaaaaaaaa      ssssssssss       ssssssssss     aaaaaaaaaaaaa   iiiiiiinnnn  nnnnnnnn        ssssssssss   
#   a::::::::::::a   ss::::::::::s    ss::::::::::s    a::::::::::::a   ss::::::::::s    ss::::::::::s    a::::::::::::a  i:::::in:::nn::::::::nn    ss::::::::::s  
#   aaaaaaaaa:::::ass:::::::::::::s ss:::::::::::::s   aaaaaaaaa:::::ass:::::::::::::s ss:::::::::::::s   aaaaaaaaa:::::a  i::::in::::::::::::::nn ss:::::::::::::s 
#            a::::as::::::ssss:::::ss::::::ssss:::::s           a::::as::::::ssss:::::ss::::::ssss:::::s           a::::a  i::::inn:::::::::::::::ns::::::ssss:::::s
#     aaaaaaa:::::a s:::::s  ssssss  s:::::s  ssssss     aaaaaaa:::::a s:::::s  ssssss  s:::::s  ssssss     aaaaaaa:::::a  i::::i  n:::::nnnn:::::n s:::::s  ssssss 
#   aa::::::::::::a   s::::::s         s::::::s        aa::::::::::::a   s::::::s         s::::::s        aa::::::::::::a  i::::i  n::::n    n::::n   s::::::s      
#  a::::aaaa::::::a      s::::::s         s::::::s    a::::aaaa::::::a      s::::::s         s::::::s    a::::aaaa::::::a  i::::i  n::::n    n::::n      s::::::s   
# a::::a    a:::::assssss   s:::::s ssssss   s:::::s a::::a    a:::::assssss   s:::::s ssssss   s:::::s a::::a    a:::::a  i::::i  n::::n    n::::nssssss   s:::::s 
# a::::a    a:::::as:::::ssss::::::ss:::::ssss::::::sa::::a    a:::::as:::::ssss::::::ss:::::ssss::::::sa::::a    a:::::a i::::::i n::::n    n::::ns:::::ssss::::::s
# a:::::aaaa::::::as::::::::::::::s s::::::::::::::s a:::::aaaa::::::as::::::::::::::s s::::::::::::::s a:::::aaaa::::::a i::::::i n::::n    n::::ns::::::::::::::s 
#  a::::::::::aa:::as:::::::::::ss   s:::::::::::ss   a::::::::::aa:::as:::::::::::ss   s:::::::::::ss   a::::::::::aa:::ai::::::i n::::n    n::::n s:::::::::::ss  
#   aaaaaaaaaa  aaaa sssssssssss      sssssssssss      aaaaaaaaaa  aaaa sssssssssss      sssssssssss      aaaaaaaaaa  aaaaiiiiiiii nnnnnn    nnnnnn  sssssssssss    
                                                                                                                                                           
#                                                  dddddddd                                                                                                         
#                                                  d::::::d                                                                                                         
#                                                  d::::::d                                                                                                         
#                                                  d::::::d                                                                                                         
#                                                  d:::::d                                                                                                          
#     cccccccccccccccc   ooooooooooo       ddddddddd:::::d     eeeeeeeeeeee                                                                                         
#   cc:::::::::::::::c oo:::::::::::oo   dd::::::::::::::d   ee::::::::::::ee                                                                                       
#  c:::::::::::::::::co:::::::::::::::o d::::::::::::::::d  e::::::eeeee:::::ee                                                                                     
# c:::::::cccccc:::::co:::::ooooo:::::od:::::::ddddd:::::d e::::::e     e:::::e                                                                                     
# c::::::c     ccccccco::::o     o::::od::::::d    d:::::d e:::::::eeeee::::::e                                                                                     
# c:::::c             o::::o     o::::od:::::d     d:::::d e:::::::::::::::::e                                                                                      
# c:::::c             o::::o     o::::od:::::d     d:::::d e::::::eeeeeeeeeee                                                                                       
# c::::::c     ccccccco::::o     o::::od:::::d     d:::::d e:::::::e                                                                                                
# c:::::::cccccc:::::co:::::ooooo:::::od::::::ddddd::::::dde::::::::e                                                                                               
#  c:::::::::::::::::co:::::::::::::::o d:::::::::::::::::d e::::::::eeeeeeee                                                                                       
#   cc:::::::::::::::c oo:::::::::::oo   d:::::::::ddd::::d  ee:::::::::::::e                                                                                       
#     cccccccccccccccc   ooooooooooo      ddddddddd   ddddd    eeeeeeeeeeeeee                                                                                       
                                                                                                                                                                  

#                   _          _   _              
#   __ _ _ ___ __ _| |_ ___ __| | | |__ _  _      
#  / _| '_/ -_/ _` |  _/ -_/ _` | | '_ | || |     
#  \__|_| \___\__,_|\__\___\__,_| |_.__/\_, |     
#                                       |__/      
#   _  _ _    _     ___                 _      _  
#  | \| (_)__| |__ | _ \___ _ __  _____| |__ _| | 
#  | .` | / _| / / |   / _ | '  \(_-/ _` / _` | | 
#  |_|\_|_\__|_\_\ |_|_\___|_|_|_/__\__,_\__,_|_| 
#            ___ __ ___ ____                      
#   __ ___  |_  /  |_  |__ /                      
#  / _/ _ \  / | () / / |_ \                      
#  \__\___/ /___\__/___|___/                      
'''                                            
                                                                                                      

from flask import Flask, redirect, url_for, render_template, request, flash
from openpyxl import load_workbook
import random                                                                       # Sun Tzu Quotes and Target Assignments
import datetime                                                                     # Date and time for calendar and updates
import hashlib                                                                      # Profile URL and Team ID encoding
import os, sys                                                                      # File management
import groupMeNotify as groupMe 

FOLDER_PATH = sys.path[0]
print(FOLDER_PATH)
 
try:
    RULESFILE = rf"{FOLDER_PATH}\app\RulesOfWar.txt"


    DATAFILE = rf"{FOLDER_PATH}\app\IndependenceAssassains.xlsx"
    QUOTEFILE = rf"{FOLDER_PATH}\app\WarQuotes.txt"
    UPDATESFILE = rf"{FOLDER_PATH}\app\Updates.txt"
    CALENDARINPUT = rf"{FOLDER_PATH}\app\Calendar.xlsx"  
    CALENDARFILE = rf"{FOLDER_PATH}\app\Calendar.txt"
    CLASSCOUNT = 500
    ENTRYCOST = 10          # Unit is dollars
    REVIVECOST = 5
    GAMEMASTERS = ['green','romsdal','auto']
    
except FileNotFoundError as f:
    print(f"ERROR: {f}")
    for i in sys.path:
        print(sys.path[i])

def generateRules():                                                    # Loads RULESFILE when needed
    ruleFile = open(RULESFILE,"r")
    rules = []
    for line in ruleFile.readlines():
        rules.append(line)
        rules.append("<br>")
        
    ruleFile.close()
        
    global ruleList
    ruleList = "".join(rules)
    
    return ruleList


class accounts():
    
    def __init__(self):
        pass
    
    def admin(self):
        pass
    
    def generateID(self, firstName: str, lastName:str, number: str):
        id_temp = (firstName[:1].lower()+lastName.lower())       # Player ID's will be the first letter of their first name, first 5 letters of their last name and the last 4 digits of their phone number
        id_characters = []
        id = 0
        for char in id_temp:                                        # getting ASCII code for each letter in id
            id_characters.append(ord(char))
        
        for digit in number:                                       # adding up every number in phone number
            id += int(digit)    
        
        for character in id_characters:
            id += int(character)
            
        encode_id = (firstName[:1].lower() + lastName.lower() + number[-4:])
        
        return id, encode_id
        
    def newAccount(self, firstName: str, lastName: str,password: str,number: str):              # Checks if account ID exists then creates account with entered information
        wb = load_workbook(DATAFILE)
        
        '''
            Usable columns and rows in each sheet (all are automatically filled by bot):
            Players:
                A2-A1000:Player ID's (See line 32 to see how they are generated)
                B2-B1000: First Names
                C2-C1000: Last Names
                D2-D1000: Status (Dead or Alive)
                E2-E1000: Special Titles (Space to show if anyone has done anything interesting)
                F2-F1000: Phone Numbers (Both for group chat and for player information)
                H2-H1000: Current Target Assignments
                I2-I1000: URL Extensions to their profile accounts
        '''
        
        sheet = wb["Players"]
        next_row = len(sheet['A']) + 1
        
        match = False                           # match will be used to tell code whether or not found an already existing ID
        
        # checking for matches of ID's

        for row in range(2, next_row):
            try:
                if id == (sheet[f"A{row}"].value):
                    
                    match = True                            # if lines 52-53 finds a match to the potential new id, it will throw 409 (Conflict Error) to show this id already exists
                
            except UnboundLocalError:
                match = False
                break
                
        if match == True:
            return 409
        
        elif match == False:
        
            # processing Player ID into database
            id = self.generateID(firstName, lastName, number)
            
            playerID = sheet.cell(row=next_row, column = 1)
            playerID.value = id[0]
            
            # processing First Name into database
            fName = sheet.cell(row=next_row, column = 2)
            fName.value = firstName
            
            # processing Last Name into database
            lName = sheet.cell(row=next_row, column = 3)
            lName.value = lastName
            
            # setting new Player to Alive
            status = sheet.cell(row = next_row, column = 4)
            status.value = "alive"
            
            # setting number of confirmed eliminations to 0
            eliminations = sheet.cell(row = next_row, column = 5)
            eliminations.value = 0
            
            # processing Phone Number into database
            phoneNumber = sheet.cell(row = next_row, column = 6)
            phoneNumber.value = number
            
            # processing password into database
            passcode = sheet.cell(row = next_row, column = 7)
            passcode.value = password
            
            # creating user's url extension to their profile page
            url_extension = sheet.cell(row = next_row, column = 8)
            url = hashlib.sha256(id[1].encode())
            url_extension.value = url.hexdigest()
                
            
            wb.save(DATAFILE)
            
            return 200                                      # if the function is run successfully (doesn't catch a matching id), it will return 200 (OK) to allow the code to continue
        
    def validateAccount(self, name, phonenumber):    
        id = []
        
        temp_name = name.lower()
        first_initial = temp_name[:1]
        id.append(first_initial)
        
        for i, char in enumerate(temp_name):
            if char == " ":
                last_name = temp_name[i+1:]
                
        id_digits = str(phonenumber)[-4:]
        id.append(id_digits)
        
        
        potential_account_id = self.generateID(firstName = first_initial, lastName = last_name, number = phonenumber)   

        # Searching digits of ids in database for possible matchs, if there are no matches, then there must not be an account registered under that name
        database = load_workbook(DATAFILE)
        sheet = database["Players"]
        next_row = len(sheet['A']) + 1
        
        # match = False                           # match will be used to tell code whether or not found an already existing ID
        
        # checking for matches of ID's

        for row in range(2, next_row):
            if potential_account_id[0]== (sheet[f"A{row}"].value):          # checking if ASCII id matches any id in the spreadsheet
                match = True
                break
                
            else:
                match = False
                
            
        if match == False:
            return 404, " "
        
        elif match == True:
            return 403, potential_account_id[1]         # returns 403 (https error for saying something is already there which is what we want it to throw) and the id that will be encoded to create the subpage
        
    def getAccount(self, data_given: str, data_known):
        """_summary_

        Args:
            data_given (str): Type of data that is known (id, name, status, url extension)
            data_known (_type_): Data that is already known (Known name, known id, etc.)

        Returns:
            _type_: _description_
        """
        database = load_workbook(DATAFILE)['Players']
        def get_data_lists(data_given):
            columns = {
                # First Array will always be the omitted columns
                'id':([['A'],['B','C','D','E','F','G','H']]),
                'name':([['B','C'],['A','D','E','F','G','H']]),
                'status': ([['D'],['A','B','C','E','F','G','H']]),
                'url_extension': ([['H'],['A','B','C','D','E','F','G']])
            }
            
            return columns.get(data_given,404)
            
        data_columns = get_data_lists(data_given)[1]
        omitted_columns = get_data_lists(data_given)[0]
        
        data = []
        '''
            Usable columns and rows in each sheet (all are automatically filled by bot):
            Players:
                A2-A1000:Player ID's (See line 32 to see how they are generated)
                B2-B1000: First Names
                C2-C1000: Last Names
                D2-D1000: Status (Dead or Alive)
                E2-E1000: Number of Confirmed Eliminations
                F2-F1000: Phone Numbers (Both for group chat and for player information)
                G2-G1000: Password
                H2-H1000: URL Extensions to their profile accounts
        '''
        
        # Return everything on the account with the id given
        for row in range(2, len(database['A']) + 1):
            if str(database[f'{omitted_columns[0]}{row}'].value) == str(data_known):
                for column in data_columns:
                    data.append(database[f"{column}{row}"].value)
            
            
        return data
        ''' In order data returns:
            [ID (if given url_extension), FIRST NAME, LAST NAME, STATUS (Dead or Alive), NUMBER OF CONFIRMED ELIMINATIONS, PHONE NUMBER, PASSWORD]
            or
            [FIRST NAME, LAST NAME, STATUS (Dead or Alive), NUMBER OF CONFIRMED ELIMINATIONS, PHONE NUMBER, PASSWORD, URL_EXTENSION (if given ID)]
        '''            
           
           
        
def generateQuote():        # Picks random Sun Tzu Quote from QUOTEFILE variable above
    
    # Geting Line Count
    file = open(QUOTEFILE,"r")
    for i, line in enumerate(file):
        pass
    lastLine = i

    
    # Getting random number
    quoteNumber = random.randint(0,lastLine)
    
    # matching random number to quote
    file.seek(0)                            # starting search back at the top.  Lines 98-100 push the "start" of the file to the last line.  Using file.seek(0) pushes the "start" back to line 1
    quotes = file.readlines()
    randomQuote = quotes[quoteNumber]
    
    return randomQuote
    
    file.close()
    
def cashPrize():            # Divide cash prize by current number of alive players from DATAFILE above
    wb = load_workbook(DATAFILE)
    
    '''
        Usable columns and rows in each sheet (all are automatically filled by bot):
        Players:
            A2-A1000:Player ID's (See line 32 to see how they are generated)
            B2-B1000: First Names
            C2-C1000: Last Names
            D2-D1000: Status (Dead or Alive)
            E2-E1000: Special Titles (Space to show if anyone has done anything interesting)
            F3-F1000: Phone Numbers (Both for group chat and for player information)
    '''
    sheet = wb["Players"]
    row_count = len(sheet['D'])
    
    alive_count = row_count
    
    for row in range(2,row_count):
        if sheet[f"D{row}"] != "alive":
            alive_count -= 1                        # Code will subtract 1 every time it does not find 'alive' in the Status slot
    
    cashprize = (ENTRYCOST*row_count)/alive_count
    
    return cashprize
    
def showUpdates():
    updateFile = open(UPDATESFILE,"r")
    updates = []
    for line in updateFile.readlines():
        updates.append(line)
        updates.append("<br>")
        
    updateFile.close()
        
    global updateList
    updateList = "".join(updates)
    
    return updateList
    
def newUpdate(update):      # To be added to the admin console to publish updates.
    updateFile = open(UPDATESFILE,"a")
    time = datetime.datetime.now()
    time = time.strftime("%m-%d-%Y %H:%M")
    update = (f"[{time}]: {update}")
    updateFile.write(update + "\n")
    updateFile.close()

class calendar():
    
    def __init__(self):
        self.CALFILE = CALENDARFILE
        self.CALINPUT = CALENDARINPUT
        
    def wipeFile(self):
        with open(self.CALFILE, "r+") as file:
            file.truncate(0)
            
        return 200
        
    def processCalendar(self):                                  
        '''Converting the Excel Spreadsheet of Calendar dates to text file 
        to be shown by computer on homepage'''
        calendarTextFile = open(self.CALFILE,"a")
        calendarWorkBook = load_workbook(self.CALINPUT,data_only=True)
        calendar = calendarWorkBook['Sheet1']
            
        events = []
            
        for i in range(2,len(calendar['A'])+1):
            if type(calendar[f'A{i}'].value) == int:
                if (calendar[f'A{i}'].value < -1):
                    continue
                else:
                    line = []
                    date = str(calendar[f'B{i}'].value)[:-9]
                    event = str(calendar[f'C{i}'].value)
                    
                    calendarTextFile.write(f"{date}:  {event} \n")
                    
        calendarTextFile.close()
        calendarWorkBook.save(self.CALINPUT)
            
    def showCalendar(self):
        
        self.wipeFile()
        self.processCalendar()
        
        calendarFile = open(self.CALFILE,"r")
        calendarList = []
        for i, row in enumerate(calendarFile.readlines()):

            calendarList.append(row)
            calendarList.append("<br>")
            calendarList.append("<br>")
            calendarList.append("<br>")
        
        
        return "".join(calendarList)

class teams():
    '''
        Required functions in teams:
            - Target assignment
            - Chances of outcome (Percentages of each team winning)
                - Base on number of kills and number of people remaining compared to other team
                    - Number of eliminations increases points (Shows they actually play the game)
                    - Lower number of team members alive lowers points (Lower number of targets for other team to get)
                    - Number of revives on each team increases points (Shows monetary and teamwork advantage)
                    - Number of underdog wins (winning despite going into round with fewer numbers) multiplies score by 1.5
                - Stats will be compared to find chances of outcome
                - Stats will also be used for leaderboard ranking 
    '''
    
    def __init__(self) -> None:
        self.DATAFILE = load_workbook(DATAFILE, data_only=True)
        self.TEAMSHEET = self.DATAFILE['Teams']
        
    def generateID(self, team_name):
        # Team ID generated by hashing the team name, converting all characters to numbers and adding all of the numbers together.
        

        encode = hashlib.sha256(team_name.encode())          #Encoding with sha256 encryption
        team_id = 0
        
        for char in encode.hexdigest():             # hexdigest function converts the encoded variable into a string to be iterable
            if type(char) != int:
                team_id += ord(char)         # If character is not a number (thus would be a string), find the ASCII code for the letter and add that instead of the letter.
            
            elif type(char) == int:
                team_id += char
                
        return team_id
        
    def set_teams(self, team_name: str, team_members: list):
        """Group teams together based on names.  
        ID's will be inputed and the function will find the names of everyone as well 
        as create an ID for the team and plug all information into the 'Teams' sheet
        in the excel spreadsheet. Function will also input the team name into the spreadsheet

        Args:
            team_members (list): Enter the list of the member ids to get Player information
        """
        
        next_clear_row = len(self.TEAMSHEET['A'])+1     # Finding next available slot
        
        '''
            Notes on each necessary column:
                A Column: Team ID (Generated by generateID() function starting at line 358)
                B Column: Team Name
                C Column: Team Member 1's ID (Found with accounts().getAccount() function starting at line 172)
                D Column: Team Member 1's Status (Dead or Alive)
                E Column: Team Member 2's ID (Found with accounts().getAccount() function starting at line 172)
                F Column: Team Member 2's Status (Dead or Alive)
                G Column: Team Member 3's ID (Found with accounts().getAccount() function starting at line 172)
                H Column: Team Member 3's Status (Dead or Alive)
                I Column: Team Member 4's ID (Found with accounts().getAccount() function starting at line 172)
                J Column: Team Member 4's Status (Dead or Alive)
        '''
        match = False
        team_id = self.generateID(team_members)
        for row in range(2, next_clear_row):
            try:
                if team_id == (self.TEAMSHEET[f"A{row}"].value):
                    print("FOUND")
                    match = True                            # if lines 52-53 finds a match to the potential new id, it will throw 409 (Conflict Error) to show this id already exists
                
            except UnboundLocalError:
                match = False
                break
                
        if match == True:
            return 409
            
        
        elif match == False:
        
            member_names = []
            
            
            for i, player in enumerate(team_members):               # Uploading player data and gathering names for team ID
                # splitting first and last name
                for j, char in enumerate(player):
                    if char == " ":
                        first_name = player[:j]
                
                player_account = accounts().getAccount('name', first_name)
                status = player_account[1]
                id = player_account[0]
                
                member_names.append(first_name)
                
                self.TEAMSHEET[f'{chr(67+(2*i))}{next_clear_row}'].value = id
                self.TEAMSHEET[f'{chr(68+(2*i))}{next_clear_row}'].value = status
                
                
                self.TEAMSHEET[f'B{next_clear_row}'].value = team_name
                self.TEAMSHEET[f'A{next_clear_row}'].value = team_id
                
            self.DATAFILE.save(DATAFILE) 
            return 200
        
    def getAccounts(self, data_type_given: str, data_known):
        """_summary_

        Args:
            data_given (str): Type of data that is known (id, name, status, url extension)
            data_known (_type_): Data that is already known (Known name, known id, etc.)

        Returns:
            _type_: _description_
        """
        database = load_workbook(DATAFILE)['Teams']
        def get_data_lists(data_type_given):
            columns = {
                # First Array will always be the omitted columns
                'id':([['A'],['B','C','D','E','F','G','H','I','J','K','L','M']]),
                'status': ([['k'],['A','B','C','D','E','F','G','H','I','J','L','M']]),
                'percent_alive': ([['L'],['A','B','C','D','E','F','G','H','I','J','K','M']])
            }
            
            return columns.get(data_type_given,404)
            
        data_columns = get_data_lists(data_type_given)[1]
        omitted_columns = get_data_lists(data_type_given)[0]
        
        data = []
        '''
            Usable columns and rows in each sheet (all are automatically filled by bot):
            Players:
                A2-A1000:Player ID's (See line 32 to see how they are generated)
                B2-B1000: First Names
                C2-C1000: Last Names
                D2-D1000: Status (Dead or Alive)
                E2-E1000: Number of Confirmed Eliminations
                F2-F1000: Phone Numbers (Both for group chat and for player information)
                G2-G1000: Password
                H2-H1000: URL Extensions to their profile accounts
        '''
        
        # Return everything on the account with the id given
        for row in range(2, len(database['A']) + 1):
            
            if str(database[f'{omitted_columns[0]}{row}'].value) == str(data_known):
                for column in data_columns:
                    data.append(database[f"{column}{row}"].value)
            
        if data == []:
            return 404
        
        else:
            return data
        ''' In order data returns:
            [ID (if given url_extension), FIRST NAME, LAST NAME, STATUS (Dead or Alive), NUMBER OF CONFIRMED ELIMINATIONS, PHONE NUMBER, PASSWORD]
            or
            [FIRST NAME, LAST NAME, STATUS (Dead or Alive), NUMBER OF CONFIRMED ELIMINATIONS, PHONE NUMBER, PASSWORD, URL_EXTENSION (if given ID)]
        '''   

    def add_team_member(self,team_name):
        '''
            1. Get team via team name
            2. Check if team is full or not
            3. If team is not full, add new member to team
        '''
        database = load_workbook(DATAFILE,data_only = True)
        team_sheet = database['Teams']
        
        for i, row in enumerate(team_sheet['A']):
            i += 2
            # print(team_sheet[f'B{i}'].value)
            print("Test",end = ":  ")
            print
            if team_sheet[f'B{i}'].value == team_name:
                print("Found")
                for member_slot in range(0,4):
                    column = chr(67+(2*member_slot))
                    
                    cell_value = team_sheet[f'{column}{i}'].value
                    print(cell_value)
                    if type(cell_value) == None:
                        print("Open Spot")
                        break
        
                
        

class targets():
    
    def __init__(self) -> None:
        self.wb = load_workbook(DATAFILE, data_only = True)
        self.ASSIGNLIST = self.wb['Target Assignments']
        
        self.team_ids = []
        
        # Automating the transferring of target assignments from teams to duos to free for all based on date
        time = datetime.datetime.now().strftime("%m/%d/%Y").split('/')     # Getting current date
        
        '''
        Year is time[2]
        Month is time[0]
        Day is time[1]
        '''
        
        calendar = load_workbook(CALENDARINPUT)['Sheet1']
        duos = str(calendar['B13'].value)[:10].split("-")                 # Date Team divides to duos must be finalized. Splitting the first 10 characters in the cell by the dashes to get the year, month, and day.
        '''
        Year is duos[0]
        Month is duos[1]
        Day is duos[2]
        '''
        
        duoSplit = datetime.date(int(duos[0]), int(duos[1]), int(duos[2]))
        curDate = datetime.date(int(time[2]), int(time[0]), int(time[1]))
        
        timeToDivide = duoSplit - curDate                                 # Subtracting the current date from the day duo Splits must be finalized        
        
        
        
        if (timeToDivide.days <= 0) and (timeToDivide.days > -26):                                             # If today is the day teams divide or after, teams will be divided
            self.FINALLIST = self.wb['Duos']
 
        if timeToDivide.days <= -26:
            self.FINALLIST = self.wb['Players']

        elif timeToDivide.days > 0:
            self.FINALLIST = self.wb['Teams']

        self.next_clear_row = len(self.FINALLIST['A'])     # Finding number of teams  
    
    def load(self):         # Set up for target assignments
        '''
            1. Put each ID into the Hunter list and Target list. 
            2. Pick a random number between 2 and the max number of rows filled in the Target ID list. 
            3. Check to make sure the cell has a valid ID 
            4. Check to make sure ID's do not match (If they do, pick a new number).
            5. If the ID's do not match, clear the cell in the Target list and move what was in that cell to row in M column of 'Teams' sheet.
            6. Repeat from step 2.
        '''
        for team in range(2, self.next_clear_row+1):
            team_id = self.FINALLIST[f'A{team}'].value
            self.ASSIGNLIST[f'A{team}'].value = team     # Adding team to hunter list
            self.ASSIGNLIST[f'B{team}'].value = team_id     # Adding team to hunter list
            self.ASSIGNLIST[f'C{team}'].value = team_id     # Adding team to target list
            
        self.wb.save(DATAFILE)
    
    def assign(self):
        total_team_count = len(self.ASSIGNLIST['A'])

        
                     # hunter id will be first followed by the target id 
        for team_id in range(2,total_team_count + 1):
            match = True
            global ties
            ties = []  
            while match == True:
                available_target_count = len(self.ASSIGNLIST['C'])
                
                assignment = random.randint(2, int(available_target_count))
                target = self.ASSIGNLIST[f'C{assignment}'].value
                hunter = self.ASSIGNLIST[f'B{team_id}'].value
                hunter_row = self.ASSIGNLIST[f'A{team_id}'].value
                # print(f"{hunter}   {target}")
                if (target == hunter) or (target == None):
                    match = True
                elif target != hunter:
                    self.FINALLIST[f'M{hunter_row}'].value = target
                    self.ASSIGNLIST[f'C{assignment}'].value = None
                    match = False
                    ties.append(hunter)
                    ties.append(target)
                    
                    
            # print(target)
            self.team_ids.append(ties)       
            # print("Target Assigned")
            
        self.wb.save(DATAFILE)
        return self.team_ids
        
    def showPairs(self):
        
        pairs = []
        for i in range(2,(self.next_clear_row + 1)):
            hunter = self.FINALLIST[f'A{i}'].value
            target = self.FINALLIST[f'M{i}'].value
            pairs.append(f"{hunter} is hunting {target}.<br></br>")
            
        return pairs
        # for i, pair in enumerate(cur_assignments):
        #         cur_assignments[i] = (f"{pair[0]} is hunting {pair[1]}.<br></br>")
                
        # return cur_assignments
                    
    def wipe(self):                 # Clearing ASSIGNLIST and current target assignments
        for team in range(2,self.next_clear_row + 1):
            self.FINALLIST[f'M{team}'].value = None
            self.ASSIGNLIST[f'A{team}'].value = None
            self.ASSIGNLIST[f'B{team}'].value = None
            self.ASSIGNLIST[f'C{team}'].value = None
            
        self.wb.save(DATAFILE)
    
    def status_check(self, admin:str = None, password:str = None):         
        ''' Check status and edit status of any team. 
        If admin matches either gamemaster username and password matches correct password (admin username) then status can be manually changed.
        '''
        if (admin.lower in GAMEMASTERS) and (password == 'c1f96b08fa7efdfb3732fca9db56e39a594944b2b14c5a95cce11a2e24de5b2d'):
            pass
        
        else:
            pass
        
    def backgroundTarget(self, hunter_information:int):
        '''
            Given the id of the hunting team, this function will return the names of each player that is tied to the target
        ''' 
        
        for i in range(2, self.next_clear_row):
            if self.FINALLIST[f"A{i}"].value == hunter_information:
                if self.FINALLIST.title == "Teams":         # Target ID's are in different columns based on the team sizes
                    target_id = self.FINALLIST[f"M{i}"].value
                    # target_id = 4533
                    target_data = teams().getAccounts('id',target_id)
                    player_info = []
                    for j in range(1,8,2):
                        
                        player = accounts().getAccount('id',target_data[j])     # Gets information on account tied to this id
                        
                        player_info.append(player[0] + " " + player[1])                    # Player first and last name
                        player_info.append(player[2])                                      # Player status (dead or alive)
                        player_info.append(player[3])                                # Number of eliminations
                        
                    
                    
                    break
        
        team_info = []
        
        team_info.append(target_id)
        
        for i in range(0,len(player_info),3):                                      # Using for loop to divide information up by player
            player_data = []
            for j in range(0,3):
                player_data.append(player_info[i+j])
            
            team_info.append(player_data)
        
        return team_info
        
    def editTargets(self,cur_assignments, hunter_id, new_target_id):
        '''
            #1. Find the hunter id in the line up
            #2. Get current target id
            3. Find what id is currently hunting the new target
            4. Swap target ids
        '''    
        
        # Finding hunter id 
        for i, pair in enumerate(cur_assignments):
            if str(pair[0]) == hunter_id:               # First index of pair nested list will be the hunter id
                cur_target = [pair[1], (i+2)]                    # Second index of pair nested list will be the current target id that is being swapped out

            
            if str(pair[1]) == new_target_id:
                new_hunter = [pair[0], (i+2)]

            
        if str(cur_target[0]) == str(new_hunter[0]):
            return 401
            
        
        if str(cur_target[0]) != str(new_hunter[0]):
            self.FINALLIST[f"M{new_hunter[1]}"].value = cur_target[0]
            self.FINALLIST[f"M{cur_target[1]}"].value = new_target_id
            self.wb.save(DATAFILE)
            return 200

        
        
    
# Everything above this line is backend management, below this line is front end:
###########################################    

app = Flask(__name__)

@app.errorhandler(404)
def page_not_found(e):
    # Standard Error Page for any issue
    return render_template("error.html"), 404

@app.route('/', methods = ["POST", "GET"])
def home():
    
    if request.method == "POST":
        
        if request.form["login"]:
            return redirect(url_for('login'))
    
    return render_template('home.html', 
                           ruleList = generateRules(), 
                           quote = generateQuote(), 
                           cashPerWinner = cashPrize(),
                           updates = showUpdates(),
                           events = calendar().showCalendar())

@app.route('/login/', methods = ["POST","GET"])
def login():
    
    global signin_stauts
    
    account_status = " "
    
    if request.method == "POST":
        if request.form.get("Login",False):
            name = request.form.get("username")
            number = request.form.get("phonenumber")
            
            if name == "c1f96b08fa7efdfb3732fca9db56e39a594944b2b14c5a95cce11a2e24de5b2d":
                return redirect(url_for('admin'))
            
            validAccount = accounts().validateAccount(name,number)
            if validAccount[0] == 404:
                print("No Account")
                account_status = f"There is no account tied to {name} with the phone number {number}.<br><br> Contact Gamemasters if this is a mistake or if you have forgotten your login information."
                
            
            if validAccount[0] == 403:
                signin_status = True
                print("Account found")
                url = hashlib.sha256(validAccount[1].encode())
                return redirect(url_for('profile',extension = url.hexdigest()))
        

    
    return render_template('login.html', 
                        ruleList = generateRules(),
                        events = calendar().showCalendar(),
                        account_status = account_status)

@app.route('/profile/<extension>')
def profile(extension):
    print(extension)
    profile_information = accounts().getAccount('url_extension',extension)
    print(profile_information)
    name = profile_information[1] + " " + profile_information[2]
    if profile_information[3] == "alive":
        status = "Not dead yet."
    elif profile_information[3] == "dead":
        status = "Fought hard. Died hard."
    
    eliminations = profile_information[4]
    phone_number = profile_information[5]
    
    return render_template("profile.html", extension = extension, user = name, status = status, phone_number = phone_number, eliminations = eliminations)

@app.route('/admin/c1f96b08fa7efdfb3732fca9db56e39a594944b2b14c5a95cce11a2e24de5b2d', methods = ["POST","GET"])
def admin():
    '''
    Admin Features:
        - Publish updates to game home page (COMPLETE)
        - Create Target Assignments         (COMPLETE)
        - Edit Target Assignments           (COMPLETE)
        - Create New Accounts               (NOT STARTED)
        - Disqualify Players                (NOT STARTED)
        - Change status of Players          (NOT STARTED)
    '''
    confirmation = ""
    assignments = ""
    target_modification = ""
    if request.method == "POST":
        
        if request.form.get("update_submit",False):
            
            update_content = request.form.get("update_text")        # Getting the message that will be added to the update
            newUpdate(update_content)
            confirmation = "Update has been posted."                # Return feedback saying update has been posted
            
            pass
            
        if request.form.get("assign_submit", False):
            print("Assigning Targets")
            
            global raw_assignments
            raw_assignments = targets().assign()
            assignments = targets().showPairs()
            assignments = ",".join(assignments)
            assignments = assignments.replace(",","")
                
            # except PermissionError:
            #     match_ups = "The database for target assignments is currently in use. Make sure the database is saved and closed before trying again."

            
            pass
        
        if request.form.get("load_assignments", False):
            try:
                targets().wipe()
                targets().load()
            except PermissionError:
                match_ups = "The database for target assignments is currently in use. Make sure the database is saved and closed before trying again."

            pass
        
        if request.form.get('edit_submit',False):
            try:
                edit = request.form.get('edit_targets')
                if edit == None:
                    edit = ""
                hunter, new_target = edit.split(":")
                
            except ValueError or AttributeError:
                pass
            
            try:
                change = targets().editTargets(raw_assignments,hunter,new_target)
                if change == 401:
                    target_modification = "This edit cannot be made because the current target would be hunting themselves.<br></br>Please select another team to swap with.<br></br>"
                    pass
                    
                if change == 200:
                    target_modification = "Target has been changed"
                    pass
                    
                assignments = targets().showPairs()
                assignments = ",".join(assignments)
                assignments = assignments.replace(",","")
            
            except NameError:
                target_modification = "Assign teams before trying to make any edits.<br></br>"
                pass
            
        if request.form.get('add_account', False):

            name = request.form.get('name')
            firstName, lastName = name.split(' ')               # splitting name into first name and last name on the space
            
            password = request.form.get('password')
            
            number = request.form.get('phone_number')
            
            if accounts().validateAccount(name = name, phonenumber=number) == 404:
                accounts().newAccount(firstName = firstName, lastName = lastName, password = password, number = number)
            
            # team_name = request.form.get('team_name')
            # team_id = teams().generateID(team_name)
            # if teams().getAccounts(data_type_given = "id", data_known = team_id) == 404:
            #     teams().set_teams(team_name = team_name, team_members = )
            
                
                
                


            
    return render_template('admin.html', confirm = confirmation, match_ups = assignments, target_modifications = target_modification)


if __name__ == "__main__":
    # app.run(host = "0.0.0.0", debug = True)
    teams().add_team_member(team_name = "Breaking Bad Man")


